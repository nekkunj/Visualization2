# -*- coding: utf-8 -*-
"""Accident_Visualizations.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p7LcBUkfRHLD_j-UoaPHRLsVok4cp-Nv
"""

# pages/06_Accident_Visualizations.py
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px # Useful for consistent color scales

# --- Data Loading and Cleaning (Cached for Performance) ---

@st.cache_data
def load_and_clean_data():
    """
    Loads and cleans the accident data for the Accident Visualizations page.
    This function is cached for performance.
    """
    try:
        df = pd.read_csv('assets/data_fusionnee.csv')
        df.columns = df.columns.str.strip().str.replace('"', '').str.replace('\t', '')
        df = df.rename(columns=lambda x: x.strip())

        # Map GRAVITE to desired labels for consistency across app
        df['GRAVITE'] = df['GRAVITE'].replace({
            'Dommages matériels seulement': 'Matériels',
            'Dommages matériels inférieurs au seuil de rapportage': 'Mineurs',
            'Léger': 'Léger',
            'Mortel ou grave': 'Grave'
        })

        return df
    except FileNotFoundError:
        st.error("Error: 'assets/data_fusionnee.csv' not found. Please ensure the file is in the 'assets' directory.")
        st.stop()
    except Exception as e:
        st.error(f"An error occurred while loading data: {e}")
        st.stop()

df = load_and_clean_data()

# --- Chart Generation Functions ---

def accidents_by_user_type_chart(df_data, period_type='Day'):
    """
    Creates a bar chart for accidents by user type, filtered by Day or Night.
    period_type: 'Day' or 'Night'
    """
    usager_cols = {
        'IND_AUTO_CAMION_LEGER': 'Light Vehicles',
        'IND_VEH_LOURD': 'Heavy Vehicles',
        'IND_MOTO_CYCLO': 'Motorcycles',
        'IND_VELO': 'Bicycles',
        'IND_PIETON': 'Pedestrians'
    }

    # Create a local copy to avoid modifying the cached DataFrame directly
    df_copy = df_data.copy()

    # Convert 'O'/'N' to 1/0 for user type indicators
    for col in usager_cols.keys():
        if col in df_copy.columns:
            df_copy[col] = df_copy[col].replace({'O': 1, 'N': 0})
        else:
            st.warning(f"Column '{col}' not found in data for user type analysis.")
            return go.Figure().update_layout(title="Data column missing for User Type analysis.")

    # Define Day/Night based on HR_ACCDN
    def classify_period(hr_str):
        if pd.isna(hr_str):
            return 'Unknown'
        # Convert HR_ACCDN from string range to actual hour for better classification
        # Assuming format like 'HH:MM:SS-HH:MM:SS' or just 'HH:MM:SS'
        try:
            start_hour_str = hr_str.split('-')[0].split(':')[0]
            start_hour = int(start_hour_str)
            if 6 <= start_hour < 20: # Roughly 6 AM to 7:59 PM as Day
                return 'Day'
            else: # Roughly 8 PM to 5:59 AM as Night
                return 'Night'
        except (ValueError, IndexError):
            return 'Unknown'

    df_copy['DAY_NIGHT'] = df_copy['HR_ACCDN'].apply(classify_period)

    # Filter data for the selected period
    subset = df_copy[df_copy['DAY_NIGHT'] == period_type]

    if subset.empty:
        fig = go.Figure()
        fig.update_layout(title=f"No data for {period_type} period", xaxis_title="User Type", yaxis_title="Number of Accidents")
        return fig

    counts = subset[list(usager_cols.keys())].sum()
    counts.index = [usager_cols[col] for col in counts.index]
    counts = counts.sort_values(ascending=False)

    fig = go.Figure(go.Bar(
        x=counts.index,
        y=counts.values,
        name=period_type,
        marker_color=px.colors.qualitative.Plotly[0] if period_type == 'Day' else px.colors.qualitative.Plotly[1]
    ))

    fig.update_layout(
        title=f"Number of Accidents by User Type - {period_type}",
        xaxis_title="User Type",
        yaxis_title="Number of Accidents",
        template="plotly_white",
        hovermode="x unified"
    )
    return fig

def accident_severity_month_chart(df_data, period_type='Day'):
    """
    Creates a stacked bar chart for accident severity by month, filtered by Day or Night.
    period_type: 'Day' or 'Night'
    """
    gravite_map = {
        "Léger": "Minor",
        "Mortel ou grave": "Severe",
        "Dommages matériels seulement": "Material Damage",
        "Dommages matériels inférieurs au seuil de rapportage": "Low Damage"
    }

    df_clean = df_data.copy()
    df_clean['GRAVITE_EN'] = df_clean['GRAVITE'].map(gravite_map)
    df_clean['MS_ACCDN'] = pd.to_numeric(df_clean['MS_ACCDN'], errors='coerce').astype("Int64")

    # Define DAY/NIGHT based on HR_ACCDN
    def classify_period_severity(hr_str):
        if pd.isna(hr_str):
            return 'Unknown'
        try:
            start_hour_str = hr_str.split('-')[0].split(':')[0]
            start_hour = int(start_hour_str)
            if 6 <= start_hour < 20: # Roughly 6 AM to 7:59 PM as Day
                return 'Day'
            else: # Roughly 8 PM to 5:59 AM as Night
                return 'Night'
        except (ValueError, IndexError):
            return 'Unknown'

    df_clean['DAY_NIGHT'] = df_clean['HR_ACCDN'].apply(classify_period_severity)
    df_clean = df_clean.dropna(subset=['GRAVITE_EN', 'MS_ACCDN', 'DAY_NIGHT'])

    # Filter data for the selected period
    grouped = df_clean[df_clean['DAY_NIGHT'] == period_type]
    grouped = grouped.groupby(['MS_ACCDN', 'GRAVITE_EN']).size().reset_index(name='Count')

    if grouped.empty:
        fig = go.Figure()
        fig.update_layout(title=f"No data for {period_type} period", xaxis_title="Month", yaxis_title="Number of Accidents")
        return fig

    month_labels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    severity_order = ["Severe", "Minor", "Material Damage", "Low Damage"]
    color_map = {
        "Severe": "darkred",
        "Minor": "lightgreen",
        "Material Damage": "steelblue",
        "Low Damage": "lightgrey"
    }

    fig = go.Figure()
    for grav in severity_order:
        df_grav = grouped[grouped['GRAVITE_EN'] == grav]
        # Ensure all months are present, fill missing with 0
        counts = df_grav.set_index('MS_ACCDN').reindex(range(1, 13), fill_value=0)['Count']
        fig.add_trace(go.Bar(
            x=month_labels,
            y=counts,
            name=grav,
            marker_color=color_map.get(grav, 'gray')
        ))

    fig.update_layout(
        title=f"Monthly Accident Severity ({period_type}time)",
        xaxis_title="Month",
        yaxis_title="Number of Accidents",
        barmode='stack',
        template="plotly_white",
        hoverlabel=dict(
            bgcolor="white",
            font=dict(color="black")
        )
    )
    return fig

def generate_severe_accidents_heatmap_chart(df_data):
    """
    Generates a heatmap of severe accidents by region and month.
    """
    month_map = {
        1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr',
        5: 'May', 6: 'Jun', 7: 'Jul', 8: 'Aug',
        9: 'Sep', 10: 'Oct', 11: 'Nov', 12: 'Dec'
    }

    df_grave = df_data[df_data['GRAVITE'] == 'Grave'].dropna(subset=['REG_ADM', 'MS_ACCDN']).copy() # Use 'Grave' from our mapping

    df_grave['MS_ACCDN'] = pd.to_numeric(df_grave['MS_ACCDN'], errors='coerce').astype('Int64')
    df_grave = df_grave[df_grave['MS_ACCDN'].between(1, 12)]

    df_grave['REG_ADM'] = df_grave['REG_ADM'].str.replace(r"\s*\(\d+\)", "", regex=True)

    if df_grave.empty:
        fig = go.Figure()
        fig.update_layout(title="No severe accident data to display for heatmap.", xaxis={"visible": False}, yaxis={"visible": False})
        return fig

    pivot = df_grave.pivot_table(index='REG_ADM', columns='MS_ACCDN', aggfunc='size', fill_value=0)

    # Ensure all 12 months are in columns
    for m in range(1, 13):
        if m not in pivot.columns:
            pivot[m] = 0
    pivot = pivot[sorted(pivot.columns)] # Reorder months numerically

    x_labels = [month_map[m] for m in pivot.columns]
    y_labels = pivot.index.tolist()
    z_values = pivot.values

    # Construction du texte de hover
    hover_text = [[f"{val} severe accidents in {y_labels[i]} during {x_labels[j]}"
                   for j, val in enumerate(row)] for i, row in enumerate(z_values)]

    fig = go.Figure(data=go.Heatmap(
        z=z_values,
        x=x_labels,
        y=y_labels,
        text=hover_text,
        hoverinfo="text",
        colorscale='Reds',
        colorbar=dict(title="Accidents")
    ))

    fig.update_layout(
        title="Severe Accidents by Region and Month (Hover for Details)",
        xaxis_title="Month",
        yaxis_title="Administrative Region",
        template="plotly_white"
    )
    return fig

def generate_accident_severity_bar_chart_by_time(df_data, granularity_type='Month'):
    """
    Generates a bar chart for accident severity by month, week type, or hour range.
    granularity_type: 'Month', 'Week Type', or 'Hour Range'
    """
    gravite_map = {
        "Léger": "Minor",
        "Mortel ou grave": "Severe",
        "Dommages matériels seulement": "Material Damage",
        "Dommages matériels inférieurs au seuil de rapportage": "Low Damage"
    }
    weektype_map = {
        'SEM': 'Weekday',
        'FDS': 'Weekend'
    }

    df_clean = df_data.copy()
    df_clean['GRAVITE_EN'] = df_clean['GRAVITE'].map(gravite_map)
    df_clean['JR_SEMN_ACCDN_EN'] = df_clean['JR_SEMN_ACCDN'].map(weektype_map)
    df_clean['MS_ACCDN'] = pd.to_numeric(df_clean['MS_ACCDN'], errors='coerce').astype("Int64")

    df_clean = df_clean.dropna(subset=['GRAVITE_EN', 'MS_ACCDN', 'JR_SEMN_ACCDN_EN', 'HR_ACCDN'])

    month_labels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    weektype_order = ['Weekday', 'Weekend']
    hour_order = [
        '00:00:00-03:59:00', '04:00:00-07:59:00',
        '08:00:00-11:59:00', '12:00:00-15:59:00',
        '16:00:00-19:59:00', '20:00:00-23:59:00'
    ]

    severity_order = ["Severe", "Minor", "Material Damage", "Low Damage"]
    color_map = {
        "Severe": "darkred",
        "Minor": "lightgreen",
        "Material Damage": "steelblue",
        "Low Damage": "lightgrey"
    }

    fig = go.Figure()
    title = ""
    x_axis_title = ""
    plot_data = pd.DataFrame()
    x_labels = []

    if granularity_type == 'Month':
        title = "Accident Severity by Month"
        x_axis_title = "Month"
        # Group by month and severity
        grouped = df_clean.groupby(['MS_ACCDN', 'GRAVITE_EN']).size().reset_index(name='Count')
        plot_data = grouped.pivot(index='MS_ACCDN', columns='GRAVITE_EN', values='Count').fillna(0)
        plot_data = plot_data.reindex(range(1, 13), fill_value=0) # Ensure all months are present
        x_labels = month_labels
    elif granularity_type == 'Week Type':
        title = "Accident Severity by Week Type"
        x_axis_title = "Day Type"
        # Group by week type and severity
        grouped = df_clean.groupby(['JR_SEMN_ACCDN_EN', 'GRAVITE_EN']).size().reset_index(name='Count')
        plot_data = grouped.pivot(index='JR_SEMN_ACCDN_EN', columns='GRAVITE_EN', values='Count').fillna(0)
        plot_data = plot_data.reindex(weektype_order, fill_value=0) # Ensure order
        x_labels = weektype_order
    elif granularity_type == 'Hour Range':
        title = "Accident Severity by Time of Day"
        x_axis_title = "Hour Range"
        # Group by hour range and severity
        grouped = df_clean.groupby(['HR_ACCDN', 'GRAVITE_EN']).size().reset_index(name='Count')
        plot_data = grouped.pivot(index='HR_ACCDN', columns='GRAVITE_EN', values='Count').fillna(0)
        plot_data = plot_data.reindex(hour_order, fill_value=0) # Ensure order
        x_labels = hour_order

    if plot_data.empty:
        fig = go.Figure()
        fig.update_layout(title=f"No data for {granularity_type}", xaxis_title=x_axis_title, yaxis_title="Number of Accidents")
        return fig

    # Add traces for all severities based on the selected granularity
    for grav in severity_order:
        if grav in plot_data.columns:
            y_values = plot_data[grav]
        else:
            y_values = [0] * len(x_labels) # If severity not present, show zeros

        fig.add_trace(go.Bar(
            x=x_labels,
            y=y_values,
            name=grav,
            marker_color=color_map.get(grav, 'gray')
        ))

    fig.update_layout(
        title=title,
        xaxis_title=x_axis_title,
        yaxis_title="Number of Accidents",
        barmode='stack',
        template="plotly_white",
        hoverlabel=dict(
            bgcolor="white",
            font=dict(color="black")
        )
    )
    return fig


# --- Streamlit Layout for Accident Visualizations Page ---

st.title("Accident Visualizations Dashboard")

st.write(
    """
    Explore various visualizations related to road accidents, including user type involvement,
    monthly severity trends, regional heatmaps, and severity breakdown by time.
    """
)

st.markdown("---")

# Use st.tabs to create separate sections for each visualization
tab1, tab2, tab3, tab4 = st.tabs([
    "Accidents by User Type (Day/Night)",
    "Severity by Month (Day/Night)",
    "Severe Accidents Heatmap",
    "Severity by Time Breakdown"
])

with tab1:
    st.subheader("Comparison of User Type Involvement in Day vs Night")
    period_type_user = st.radio(
        "Select Time Period for User Type Analysis:",
        ('Day', 'Night'),
        key='user_type_period_selector'
    )
    fig_user_type = accidents_by_user_type_chart(df, period_type_user)
    st.plotly_chart(fig_user_type, use_container_width=True)

with tab2:
    st.subheader("Monthly Severity Distribution: Day vs Night")
    period_type_severity = st.radio(
        "Select Time Period for Monthly Severity Analysis:",
        ('Day', 'Night'),
        key='severity_month_period_selector'
    )
    fig_severity_month = accident_severity_month_chart(df, period_type_severity)
    st.plotly_chart(fig_severity_month, use_container_width=True)

with tab3:
    st.subheader("Severe Accidents by Region and Month")
    fig_heatmap = generate_severe_accidents_heatmap_chart(df)
    st.plotly_chart(fig_heatmap, use_container_width=True)

with tab4:
    st.subheader("Severity Breakdown: Monthly, Weekly, and Hourly Views")
    granularity_type_bar = st.radio(
        "Select Granularity for Severity Breakdown:",
        ('Month', 'Week Type', 'Hour Range'),
        key='severity_breakdown_granularity_selector'
    )
    fig_severity_breakdown = generate_accident_severity_bar_chart_by_time(df, granularity_type_bar)
    st.plotly_chart(fig_severity_breakdown, use_container_width=True)