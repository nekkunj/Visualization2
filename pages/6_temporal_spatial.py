# -*- coding: utf-8 -*-
"""Temporal_Spatial.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p7LcBUkfRHLD_j-UoaPHRLsVok4cp-Nv
"""

# pages/04_Temporal_Spatial.py
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np # For numerical operations

# --- Data Loading and Preprocessing (Cached for Performance) ---

@st.cache_data
def prep_data():
    """
    Loads and preprocesses the accident data for temporal-spatial analysis.
    This function is cached to prevent re-loading data on every rerun.
    It now relies on existing columns for temporal granularity.
    """
    try:
        df = pd.read_csv('assets/data_fusionnee.csv')

        # Clean column names (remove leading/trailing spaces and quotes)
        df.columns = df.columns.str.strip().str.replace('"', '')
        df = df.rename(columns=lambda x: x.strip())
        # st.info(f"Initial DataFrame columns after cleaning: {df.columns.tolist()}") # Debugging

        # Ensure 'AN' (Year) is integer
        if 'AN' in df.columns:
            df['AN'] = df['AN'].astype(int)
        else:
            st.error("Column 'AN' (Year) not found! Temporal analysis by year will be limited.")
            df['AN'] = np.nan # Ensure column exists even if empty

        # Map 'JR_SEMN_ACCDN' (Day Type) to 'Weekday'/'Weekend'
        if 'JR_SEMN_ACCDN' in df.columns:
            df['JR_SEMN_ACCDN'] = df['JR_SEMN_ACCDN'].replace({'SEM': 'Weekday', 'FDS': 'Weekend'})
        else:
            st.warning("Column 'JR_SEMN_ACCDN' (Day Type) not found. Day Type analysis will be unavailable.")
            df['JR_SEMN_ACCDN'] = np.nan

        # Define 'quarter_day' from 'HR_ACCDN' (Hour Range)
        if 'HR_ACCDN' in df.columns:
            def get_quarter_day(hr_str):
                if pd.isna(hr_str): return np.nan
                # Extract first two digits as hour range indicator (e.g., '08' from '08:00:00-11:59:00')
                try:
                    start_hour_prefix = hr_str.split(':')[0]
                    if start_hour_prefix.isdigit():
                        start_hour = int(start_hour_prefix)
                        if 0 <= start_hour < 6: return 'Night (0-5h)'
                        elif 6 <= start_hour < 12: return 'Morning (6-11h)'
                        elif 12 <= start_hour < 18: return 'Afternoon (12-17h)'
                        else: return 'Evening (18-23h)'
                    else:
                        return 'Unknown Hour Format'
                except (ValueError, IndexError):
                    return 'Invalid Hour Data'
            df['quarter_day'] = df['HR_ACCDN'].apply(get_quarter_day)
            # st.info("Derived 'quarter_day' from 'HR_ACCDN'.")
        else:
            st.warning("Column 'HR_ACCDN' (Hour Range) not found. Quarter of Day analysis will be unavailable.")
            df['quarter_day'] = np.nan

        # Map 'GRAVITE' to desired labels for consistency
        if 'GRAVITE' in df.columns:
            df['GRAVITE'] = df['GRAVITE'].replace({
                'Dommages matériels seulement': 'Matériels',
                'Dommages matériels inférieurs au seuil de rapportage': 'Mineurs',
                'Léger': 'Léger',
                'Mortel ou grave': 'Grave'
            })
            # st.info("Mapped 'GRAVITE' labels.")
        else:
            st.error("Column 'GRAVITE' not found! Severity analysis will be limited.")
            return pd.DataFrame() # Severity is critical, return empty DF if missing

        # Add region coordinates for mapping
        region_coords = {
            'Bas-Saint-Laurent (01)': (48.5, -68.5), 'Saguenay/-Lac-Saint-Jean (02)': (48.4, -71.1),
            'Capitale-Nationale (03)': (47.0, -71.2), 'Mauricie (04)': (46.5, -72.7),
            'Estrie (05)': (45.4, -71.9), 'Montréal (06)': (45.5, -73.6),
            'Outaouais (07)': (45.6, -76.0), 'Abitibi-Témiscamingue (08)': (48.1, -78.0),
            'Côte-Nord (09)': (50.0, -63.0), 'Nord-du-Québec (10)': (52.0, -75.0),
            'Gaspésie/-Îles-de-la-Madeleine (11)': (49.1, -65.4), 'Chaudière-Appalaches (12)': (46.5, -70.5),
            'Laval (13)': (45.6, -73.8), 'Lanaudière (14)': (46.0, -73.4),
            'Laurentides (15)': (46.5, -74.2), 'Montérégie (16)': (45.3, -73.0),
            'Centre-du-Québec (17)': (46.0, -72.0)
        }
        if 'REG_ADM' in df.columns:
            df['Region_Full'] = df['REG_ADM'].astype(str).str.strip() # Ensure string type before strip
            # Clean region names to remove numbers in parentheses for simpler 'Region' column
            df['Region'] = df['Region_Full'].str.replace(r'\s*\(\d+\)', '', regex=True).str.upper()

            df['lat'] = df['Region_Full'].map(lambda x: region_coords.get(x, (np.nan, np.nan))[0] if pd.notna(x) else np.nan)
            df['lon'] = df['Region_Full'].map(lambda x: region_coords.get(x, (np.nan, np.nan))[1] if pd.notna(x) else np.nan)
            # st.info("Region coordinates mapped.")
        else:
            st.error("Column 'REG_ADM' not found! Map functionalities will be unavailable.")
            df['Region_Full'] = np.nan
            df['Region'] = np.nan
            df['lat'] = np.nan
            df['lon'] = np.nan

        # Drop rows where lat/lon or Region are NaN, as these cannot be plotted on the map
        initial_rows = len(df)
        df_cleaned = df.dropna(subset=['lat', 'lon', 'Region'], how='any')
        rows_dropped = initial_rows - len(df_cleaned)
        # if rows_dropped > 0:
            # st.warning(f"Dropped {rows_dropped} rows with missing map coordinates or region names for plotting.")
        df = df_cleaned # Update df to the cleaned version
        # st.success(f"Data preprocessing complete. Final DataFrame shape: {df.shape}")
        return df
    except FileNotFoundError:
        st.error("Error: 'assets/data_fusionnee.csv' not found. Please ensure the file is in the 'assets' directory.")
        st.stop() # Stop the app if crucial file is missing
    except Exception as e:
        st.error(f"An unexpected error occurred during data loading: {e}")
        st.exception(e) # Display full traceback in Streamlit
        st.stop() # Stop the app on critical error

# --- Helper Functions for Plotting ---

def prepare_region_data(data_frame):
    """Aggregates accident counts per region for the map."""
    # st.info("Preparing region data for map...")
    if data_frame.empty or 'Region' not in data_frame.columns or data_frame['Region'].empty:
        st.warning("No 'Region' column or it's empty in input data for map preparation.")
        return pd.DataFrame()

    region_counts = data_frame.groupby('Region').size().reset_index(name='Accident Count')
    # Merge back with original df to get lat/lon for each region (ensure unique mapping)
    region_coords_df = data_frame[['Region', 'lat', 'lon']].drop_duplicates(subset=['Region']).dropna(subset=['lat', 'lon'])
    merged_df = pd.merge(region_counts, region_coords_df, on='Region', how='left')
    # st.info(f"Prepared map data shape: {merged_df.shape}")
    return merged_df

def draw_geo_map(data_frame, center_lat, center_lon, zoom):
    """Draws a scatter_mapbox chart of Quebec regions based on accident counts."""
    # st.info("Drawing geographical map...")
    if data_frame.empty or 'lat' not in data_frame.columns or 'lon' not in data_frame.columns or 'Accident Count' not in data_frame.columns:
        fig = go.Figure()
        fig.update_layout(title="No map data to display. Please check data and filters.")
        st.warning("No valid data for geographical map.")
        return fig

    fig = px.scatter_mapbox(
        data_frame,
        lat='lat',
        lon='lon',
        color='Accident Count',
        size='Accident Count',
        hover_name='Region',
        hover_data={'Accident Count': True, 'lat': False, 'lon': False},
        color_continuous_scale=px.colors.sequential.Plasma,
        zoom=zoom,
        center={"lat": center_lat, "lon": center_lon},
        height=600,
        title="Accidents by Region"
    )
    fig.update_layout(
        mapbox_style="open-street-map",
        margin={"r":0,"t":30,"l":0,"b":0}
    )
    # st.success("Map figure created successfully.")
    return fig

def create_bar_chart(data_frame, title, type_col, granularity_col):
    """Creates a grouped bar chart by granularity and severity."""
    # st.info(f"Creating bar chart: '{title}' using granularity '{granularity_col}' and type '{type_col}'")
    if data_frame.empty:
        fig = go.Figure()
        fig.update_layout(title=f"No data for {title}", xaxis={"visible": False}, yaxis={"visible": False})
        st.warning(f"Empty DataFrame passed to create_bar_chart for '{title}'.")
        return fig

    # Ensure required columns exist
    if granularity_col not in data_frame.columns or type_col not in data_frame.columns:
        st.error(f"Missing required columns for bar chart '{title}': '{granularity_col}' or '{type_col}'. Dataframe columns: {data_frame.columns.tolist()}")
        fig = go.Figure()
        fig.update_layout(title=f"Error: Missing columns for '{title}'")
        return fig

    # Group by granularity and severity
    grouped_df = data_frame.groupby([granularity_col, type_col]).size().reset_index(name='Count')
    # st.info(f"Grouped DataFrame shape for bar chart '{title}': {grouped_df.shape}")

    # Define a consistent order for severity
    severity_order = ['Grave', 'Léger', 'Matériels', 'Mineurs']
    existing_severities_in_grouped = [s for s in severity_order if s in grouped_df[type_col].unique()]
    if existing_severities_in_grouped:
        grouped_df[type_col] = pd.Categorical(grouped_df[type_col], categories=severity_order, ordered=True)
        grouped_df = grouped_df.sort_values(type_col)
        # st.info("Severity categories ordered for bar chart.")
    else:
        st.warning(f"No known severities ('Grave', 'Léger', 'Matériels', 'Mineurs') found in data for '{title}'. Plotting without specific severity order for this chart.")

    # Order for granularity columns if applicable
    order_dict = None
    if granularity_col == 'MS_ACCDN': # Original Month column
        order_dict = {'MS_ACCDN': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]}
    elif granularity_col == 'quarter_day':
        order_dict = {'quarter_day': ['Night (0-5h)', 'Morning (6-11h)', 'Afternoon (12-17h)', 'Evening (18-23h)']}
    elif granularity_col == 'JR_SEMN_ACCDN': # Original Day Type column
        order_dict = {'JR_SEMN_ACCDN': ['Weekday', 'Weekend']}
    elif granularity_col == 'AN': # For Year
        if 'AN' in data_frame.columns:
             order_dict = {'AN': sorted(data_frame['AN'].dropna().astype(int).unique().tolist())}
        else:
            st.warning("Year column 'AN' not available for ordering.")
            order_dict = None
    # st.info(f"Granularity order dictionary for bar chart: {order_dict}")

    fig = px.bar(
        grouped_df,
        x=granularity_col,
        y='Count',
        color=type_col,
        title=title,
        barmode='group',
        labels={'Count': 'Number of Accidents'},
        category_orders=order_dict,
        color_discrete_map={
            'Grave': 'red',
            'Léger': 'orange',
            'Matériels': 'blue',
            'Mineurs': 'green'
        }
    )
    # st.success("Bar chart figure created successfully.")
    return fig

# --- Main Streamlit App Layout Function ---
def show_temporal_spatial_page():
    # Load data once for the page. This function handles caching internally.
    df = prep_data()

    if df.empty:
        st.error("Data loading failed or resulted in an empty DataFrame. Cannot render the full page.")
        return # Stop rendering if no data is available

    # --- Session State Initialization ---
    if 'selected_region' not in st.session_state:
        st.session_state['selected_region'] = None
    # st.info(f"Initial selected_region in session state: {st.session_state['selected_region']}")

    st.title("Spatio-Temporal Analysis: Quebec Road Safety")

    st.write(
        """
        This interactive dashboard visualizes the spatio-temporal distribution of road accidents in Quebec.
        Click on a region on the map to explore accident trends over time by severity for that specific region.
        Use the time granularity selectors to zoom from annual to daily patterns.
        The goal is to help identify high-risk zones and better understand accident dynamics.
        """
    )

    st.markdown("---")

    # Layout using st.columns for side-by-side display
    col_map, col_region_chart = st.columns([2, 1])
    # st.info("Layout columns created for map and regional chart.")

    with col_map:
        st.subheader("Accidents by Region (Click on a region)")

        df_map_data = prepare_region_data(df)
        if df_map_data.empty:
            st.warning("No map data available after aggregation. Displaying empty map.")
            fig_map = go.Figure().update_layout(title="No map data to display.")
        else:
            fig_map = draw_geo_map(df_map_data, center_lat=47.5, center_lon=-71.5, zoom=4.5)

        try:
            map_chart_selection = st.plotly_chart(
                fig_map,
                use_container_width=True,
                on_select="streamlit",
                key='accident-map'
            )
            # st.info(f"Map displayed. Map selection data: {map_chart_selection}")

        except Exception as e:
            st.error(f"Error rendering map: {e}")
            st.exception(e)
            map_chart_selection = None

        # Process map click/selection data
        # Check if map_chart_selection is a dictionary (meaning a selection event occurred)
        if isinstance(map_chart_selection, dict) and map_chart_selection.get('selection') and map_chart_selection['selection'].get('points'):
            point_data = map_chart_selection['selection']['points'][0]
            clicked_region_name = None

            if 'hovertext' in point_data:
                clicked_region_name = point_data['hovertext']
            elif 'customdata' in point_data and isinstance(point_data['customdata'], list) and point_data['customdata']:
                clicked_region_name = point_data['customdata'][0]

            if clicked_region_name:
                if st.session_state['selected_region'] != clicked_region_name:
                    st.session_state['selected_region'] = clicked_region_name
                    # st.success(f"Region selected: **{clicked_region_name}**. Refreshing regional chart...")
                    st.rerun()
            else:
                st.session_state['selected_region'] = None
                st.warning("Could not extract region name from map click data. Setting selected_region to None.")
        # If selection is explicitly cleared (e.g., clicking off points on the map)
        elif isinstance(map_chart_selection, dict) and not map_chart_selection.get('selection') and st.session_state['selected_region'] is not None:
            st.session_state['selected_region'] = None
            # st.info("Map selection cleared. Regional chart will reset.")
            st.rerun()
        # Initial load case or if map_chart_selection is DeltaGenerator (no selection yet)
        elif not isinstance(map_chart_selection, dict) and st.session_state['selected_region'] is not None:
             # Do nothing if it's the initial render or DeltaGenerator but a region is already selected
             pass # This avoids unnecessary reruns or clearing a pre-existing selection
        else: # This covers the case where it's DeltaGenerator and selected_region is already None
             pass # No action needed

    with col_region_chart:
        st.subheader("Accidents in Selected Region")

        # Options now reflect the actual column names from your data
        granularity_region_selector_options = [
            {'label': 'Year', 'value': 'AN'},
            {'label': 'Month', 'value': 'MS_ACCDN'}, # Use MS_ACCDN directly
            {'label': 'Day Type (Weekday/Weekend)', 'value': 'JR_SEMN_ACCDN'}, # Use JR_SEMN_ACCDN directly
            {'label': 'Quarter of Day', 'value': 'quarter_day'}
        ]
        granularity_region_selector = st.selectbox(
            "Select Time Granularity (Region):",
            options=granularity_region_selector_options,
            format_func=lambda x: x['label'],
            index=0,
            key='granularity-region-selector'
        )
        granularity_region_col = granularity_region_selector['value']
        # st.info(f"Regional chart granularity selected: {granularity_region_col}")

        if st.session_state['selected_region']:
            # st.info(f"Attempting to show data for: **{st.session_state['selected_region']}** using '{granularity_region_col}' granularity.")
            filtered_df_region = df[df['Region'] == st.session_state['selected_region']].copy()

            if not filtered_df_region.empty:
                fig_region_bar = create_bar_chart(
                    filtered_df_region,
                    f"Accidents in {st.session_state['selected_region']} by {granularity_region_selector['label']}",
                    'GRAVITE',
                    granularity_region_col
                )
                st.plotly_chart(fig_region_bar, use_container_width=True)
                # st.success(f"Regional chart for {st.session_state['selected_region']} displayed.")
            else:
                st.warning(f"No accident data available for **{st.session_state['selected_region']}** with current granularity.")
                st.markdown(
                    """
                    <div style="padding: 10px; background-color: #f8d7da; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.05); height: 500px; display: flex; align-items: center; justify-content: center; text-align: center; color: #721c24;">
                        <p style="font-size: 14px; font-weight: bold;">No data for selected region and granularity.</p>
                        <p style="font-size: 12px; color: #721c24;">Try selecting a different granularity or region.</p>
                    </div>
                    """,
                    unsafe_allow_html=True
                )
        else:
            st.markdown(
                """
                <div style="padding: 10px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.05); height: 500px; display: flex; align-items: center; justify-content: center; text-align: center;">
                    <p style="font-size: 14px; color: #555;">Click on a region on the map to see its accident trends over time.</p>
                </div>
                """,
                unsafe_allow_html=True
            )

    st.markdown("---")

    st.subheader("Accidents by Time and Severity (Global)")

    # Options now reflect the actual column names from your data
    granularity_global_selector_options = [
        {'label': 'Year', 'value': 'AN'},
        {'label': 'Month', 'value': 'MS_ACCDN'}, # Use MS_ACCDN directly
        {'label': 'Day Type (Weekday/Weekend)', 'value': 'JR_SEMN_ACCDN'}, # Use JR_SEMN_ACCDN directly
        {'label': 'Quarter of Day', 'value': 'quarter_day'}
    ]
    granularity_global_selector = st.selectbox(
        "Select Time Granularity (Global):",
        options=granularity_global_selector_options,
        format_func=lambda x: x['label'],
        index=0,
        key='granularity-selector'
    )
    granularity_global_col = granularity_global_selector['value']
    # st.info(f"Global chart granularity selected: {granularity_global_col}")

    if not df.empty:
        fig_global_bar = create_bar_chart(
            df, # Use the full DataFrame for global view
            f"Accidents by {granularity_global_selector['label']} (Global)",
            'GRAVITE',
            granularity_global_col
        )
        st.plotly_chart(fig_global_bar, use_container_width=True)
        # st.success("Global chart displayed.")
    else:
        st.warning("No global accident data available to display charts.")

# Call the function to run the Streamlit page content
if __name__ == "__main__":
    show_temporal_spatial_page()